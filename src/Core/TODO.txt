
SHORT-TERM
----------
(+++)   [Scoped type variables] Redesign the behaviour of named tyvars and fix unification problems with them. OCaml documentations says:
            "The type expression ' ident stands for the type variable named ident. The type expression _ stands for an anonymous type variable.
            In data type definitions, type variables are names for the data type parameters. In type constraints, they represent unspecified types that
            can be instantiated by any type to satisfy the type constraint. In general the scope of a named type variable is the whole top-level phrase
            where it appears, and it can only be generalized when leaving this scope. Anonymous variables have no such restriction.
            In the following cases, the scope of named type variables is restricted to the type expression where they appear:
                1) for universal (explicitly polymorphic) type variables;
                2) for type variables that only appear in public method specifications (as those variables will be made universal, as described in section 6.9.1);
                3) for variables used as aliases, when the type they are aliased to would be invalid in the scope of the enclosing definition (i.e. when it
                        contains free universal type variables, or locally defined types.)"

(+++)   [Imperative blocks] Deal with imperative block wisely: 'do' (both single and do {..} blocks) must behave like a binding and should be mixed with lets without the need for the final 'in'.

(+++)   [Closed-world overloading] Suppoty let over without overload, resolved locally and immediately.

(++)    [Ticked identifiers] Redesign all the ticked identifiers and make the whole thing consistent:
                  X | x     = Var      =>  typing must discriminate between variable names and data constructor names
                  'X | 'x   = FreeVar  =>  typing must discriminate between constrained variable names and constrained data constructor names
                  `X        = PolyCons =>  polymorphic variant
                  `x        = ?        =>  does it make sense? can it be used for something?

(++)    [Record label and variant overloading] Design and implement rewrite_row and unification with multiple types per label and unleash the power of overloading
            even on row types in a context-dependent fashion.

(++)    [Multiple overload..and = typeclasses] Consider supporting multiple overload principal type declarations and study the relation with scoped named type variables.
            Could they resemble a form of implicit type classes? E.g. all symbols within an overload..and group could be put into the constraints even if only one of them actually appear in code.
            The pragmatic benefit is that type variables can be shared between multiple overloaded symbols, like in type classes.
            One could even give a name to a set of overload principal types with a suffix "as". Or also: one could declare to overload a record type, and give birth to a real type class.

(+)     [Overloaded lambda parameters] When a lambda parameter is annotated in a special way (e.g. a special keyword or something) it is typed like a FreeVar but it brings all gathered
            constraints to the left hand of the resulting arrow type. This basically creates an intersection type which must be fully resolved (i.e. putting automatic applications)
            at call sites - opposedly to standard constraints which may or may not be fully resolved. Notice that this is an alternate interpretation of first-class polymorphism, based
            on typing differently each use of a given lambda parameter instead of annotating it with a principal polymorphic System-F type.

(+)     [Python-like 'or' construct] Design an 'or' construct like Python for dealing with optionsn in the following way:
                e1 or e2 ~~> match e1 with Some x -> x | None -> e2
              It actually matches the 'either' function, but it is infix: let (or) a b = either b a
              Also, design a special if-like construct for optionals: when e1 is x then e2 ~~~> match e1 with None -> () | Some x -> e2 x

(--)    [Type scheme annotations] Type scheme annotations should disable automatic generalization of the WHOLE type, while plain type annotations disables quantification
            only of type variables which are in scope [http://research.microsoft.com/pubs/67012/scoped.pdf]
                
(-)     [Suspension of automatic resolution] Resolution can be suspended indeterminately until explicit val construct is used; e.g. double-ticked identifiers (in the expression language) could do that.

(-)     [Ticked infix operators] Support ticked infix operators: '+ for example, as well as '`myinfix` for infixex backticked operators à la Haskell.

(-)     [Pretty printing of kinds] When printing kind annotations on types, avoid printing obvious kinds. That means not only K_Star, but also arrows when on left-hand of an application, for example.
            This problem is similar to printing parentheris in applications: integrating (|Application|) active pattern with some special behaviour might be a good idea.

(-)     [Resolution Looslyness vs Strictness] Remove constraint_mode and behave like this: overloaded constraints are loose, dynamically scoped symbols are strict.

(--)    [Datatype syntax] Change dataype syntax with '=' in place of 'with'; and support 2 syntaxes for the type name: id :: kind | ty_expr.
             Where the latter infers the kind from the type expression.

(--)    [Use-bindings] Support a use binding requiring a destructor (overloaded o recorded) and maybe even a constructor (like __enter__() in python)

(--)    [Syntax of the loosen operator] Find a better syntax for loosen operator, such as: <_ expr _>; |(expr)|; |> expr <|; <* expr *>; ]> expr <[

(--)    [Suitable operators] Some operators that might be useful for something: <!>  >=>  >*>  <*. .*>  (| |) 
              or remember we can use TILDE (~) for some special behaviours, e.g resolver best fit or strict/non-strict mode


LONG-TERM
---------

(+)     [Constraints inside first-class type schemes] This would be awesome if possible!

(+)     [GADTs] Read http://caml.inria.fr/pub/docs/manual-ocaml/extn.html#sec238 for GADTs in OCaml and reproduce the
            existentially-qualified type variable behaviour there. Among others: when a tyvar occurs in the type signature of a
            datacons but does not appear in the codomain (i.e. the gadt type itself) then it becomes existentially qualified.

(-)     [Subtyping, sub-typesets and active patterns] Design a system which reformulates active patterns as a way for defining subsets of types, i.e. subtypes.
            Consider the following example, where this variant defines the most general representation for types:
                datatype ty with
                    | T_Forall of var * ty * ty
                    | T_App of ty * ty
                    | T_Var of var
                    | T_Cons of string
                    | T_Bottom

            Users may define a subtype like this:
                datatype sysf_ty <: ty with
                    | T_Forall (α, T_Bottom, t2) -> F_Forall (α, t2)
                    | T_App (t1, t2)             -> F_App (t1, t2)
                    | T_Var α                    -> F_Var α
                    | T_Cons x                   -> F_Cons x
                    | T_Bottom                   -> let α = fresh_var () in F_Forall (α, T_Var α)

            It basically is another way of defining active patterns, in a structured and guided way.
            But not only: key point is the non-exhaustive pattern matching, which clearly implies that we're treating a subset of the original type.
            This subset can be bound to a name, and a subtype relation with the original type can be introduced.
            Explore this feature further: one might define a supertype as well by adding variants to an original type or by mapping a type to a type with more
            variants; or even type equations might be introduced in case of exhaustive pattern matching.
            Formulate these also with poly variants, not only for GADTs.
            P.S: think for example at subtypes of int for certain intervals to be passed to some functions operating in those ranges - it's like having finally a type-safe way
            for dealing with subsets of numbers and things like that! 

(-)     [Call-by-need and where-bindings] Lazyness shortcut introduced by where-bindings: call-by-need identifiers automatically recursive. Evaluated at lookup-time.

(-)     ['val' keyword for lets and 'value' for resolution] Top-level lets could be 'val x = e' (hence existing 'val' construct would become 'value'); record bindings should
            also support the val prefix: this would allow users to quickly make a record from a whole set of top-level bindings
            just by embrancing them

(-)     [Active patterns] Active patterns and syntactic sugar for patterns passed as function arguments

(-)     [Sum types] #-expressions introduces sum types. e.g: (match e with A -> #3 | B -> #true) : <int | bool>
            Row types with special labels could be used for implementing this, like tuples are made

(-)     [Multi-threaded evaluator] Implement an effect system whose goal is marking expressions in such a way that
            a massive parallel evaluator can be implemented (as in Concurrent ML).
            https://www.irisa.fr/prive/talpin/papers/jfp92.pdf
            https://books.google.it/books?id=odbvBwAAQBAJ&pg=PA4&lpg=PA4&dq=effect+system+for+ml&source=bl&ots=KUOedMnQ8I&sig=0lXYne_oAi6jFW5-kY-qICxhJYE&hl=it&sa=X&ved=0CDYQ6AEwAmoVChMIhafpiNL0yAIVw9kaCh0nBQ5M#v=onepage&q=effect%20system%20for%20ml&f=false

(-)     [References and assignments] Choose the best system for inferring refs and assignment without too much value restriction.
            http://delivery.acm.org/10.1145/100000/99622/p291-leroy.pdf?ip=157.138.17.165&id=99622&acc=ACTIVE%20SERVICE&key=4DF843340132291B%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35%2E4D4702B0C3E38B35&CFID=727079897&CFTOKEN=72912914&__acm__=1446568920_888a1e8be56e0b4667e524ff65e093a9

(--)    [Kind constraints] Does support for kind constraints make sense? (introduced by freevars, at least, if not overloading) in the type-level language.
            Might be useful for advanced type programming; and is also a beautiful simmetry

(--)    [Extensible data types] In OCaml, declaration 'type t += C of s' adds a new constructor to an existing datatype.
            Create something similar for GADTs (and for polyvariants, assuming it does make sense).

(--)    [Multi-threaded typing] Use async for pt_expr and jenv must bind to joinable values

(--)    [Pointer-based type variables] Reimplement type variables by means of pointers and rewrite substitution accordingly

(--)    [No let-rec in the type language] Lazyness and where-bindings may suffice in place of let-rec for the type language?

(--)    [Existential types] Support existential types for explicit subsumption of records. Example: let x : 'a <: { x : int } = if b then { x = 1 } else { x = 2; y = "str" }

(--)    [Better error messages] Type error messages coming from MGU are imprecise: when some subterm gets unified successfully and another part
            of it doesn't, the mismatch message prints completely un-unified types, i.e. the parts of the type that had
            already been unified appear as they were BEFORE the whole unification process. This should be fixed somehow

(--)    [Separate compilation and namespaces] Support separate compilation and namespaces. Study how they relate to modules.

(---)   [Alternate syntax for pattern matching] As of now, pattern matching supports 2 synyaxes: the arrow (->) style and the fat arrow (=>) style. Are we sure it's ok?



WEIRD & FUTURE IDEAS
--------------------

(---)   [Regular expressions on identifiers for a new form of polymorphism] This is a weird idea, but might be revolutionary: try to design a form of polymorphism over identifier names,
            like for example "*_of_int" stands for all the functions matching this id-pattern; in order to restrict the set of functions, the user might help with
            the 'like' keyword, e.g.: "*_error like type_error" meaning that only functions named "*_error" having the same or a compatible type with "type_error" must be taken.

